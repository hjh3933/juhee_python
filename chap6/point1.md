### 최단경로문제

**실생활 속 최단경로문제**

- 환승안내, 내비게이션과 같은 서비스를 구현하는 경우 여러 경로 중 가장 효율적인 경로를 찾는 알고리즘이 필요하다
- 효율적이란, 시간, 비용, 거리 등 다양한 기준을 고려할 수 있다
- 이를 수치화하여 비용(cost)이라는 값이라고 하며, 비용의 최솟값을 구하는 알고리즘을 구현한다

**최단경로를 구하는 방법**

- 첫번째는 모든 경로를 구하여 최단 경로를 찾는 방법이다, 이 방법은 경로의 수가 증가할 수록 탐색해야하는 데이터 양이 폭발적으로 증가하여 비효율적이다
- 그래프로 표현하기: 방향이 정해진 그래프를 유향 그래프, 방향이 정해지지 않은 그래프를 무향 그래프라고 한다
- 원으로 표현된 곳을 지점, 지나는 곳을 가지라고 한다
- 모든 경로를 지나는 경우 정점이 n개 있으면 복잡도는 `O(n!)`으로 n이 커질수록 급격하게 처리량이 증가한다

**경로의 수 구하기**

- 최단 경로를 구하기 전에 여러 정점이 있는 그래프를 가정하고, 가능한 경로의 수를 구하는 알고리즘을 먼저 살펴본다
- 동적계획법
  - 복잡한 문제의 해결을 위해 작은 문제로 나누고, 해당 값을 저장하여 재활용하는 계산방법
  - 가로, 세로 방향의 지점은 모두 1로 설정(첫행, 첫열)
  - 이후 왼쪽과 아래쪽의 요소를 더한 값을 차례로 대입하여 목적지에 도달하는 경로의 수를 구함
  - 문제의 그림은 5행 6열로 구성된 칸이지만, 코드에서는 왼쪽아래의 출발지점을 배열의[0][0]으로 설정하기 위해 그림을 시계방향으로 돌린 것과 같이 리스트를 구현하였으므로 해석에 유의할 것
  - 즉, 코드에서의 출발지점은 [0][0]이고 도착지점은 [M][N]이 됨

```python
route = [[0 for i in range(N + 1)] for j in range(M + 1)]

# 가로 방향의 첫 1행을 설정
for i in range(M + 1):
    route[i][0] = 1

for i in range(1, N + 1):
    # 세로 방향의 첫 1열을 설정
    route[0][i] = 1
    for j in range(1, M + 1):
        # 왼쪽과 아래쪽의 교차점에 적혀 있는 숫자를 더함
        route[j][i] = route[j - 1][i] + route[j][i - 1]
```

- 메모이제이션
  - 동적계획법의 핵심 아이디어 중 하나, 계산된 값을 저장하여 반복 계산을 피하는 방법이다
  - 재귀함수를 사용할 때 같은 계산을 반복하는 대신 저장한 값을 사용하도록 하여 처리속도를 줄일 수 있다
  - `@functools.lru_cache(maxsize=None)`: 파이썬의 내장 데코레이터인 `@functools.lru_cache`는 함수의 결과를 저장하는 역할을 한다 `maxsize=None`은 저장할 항목의 최대 크기를 제한하지 않겠다는 의미

```python
# 파이썬에서는 아래 1행만 추가하면 재귀처리를 메모이제이션 할 수 있다
@functools.lru_cache(maxsize=None)
def search(m, n):
    # 가로 세로 첫 줄은 모두 1로 설정
    if (m == 0) or (n == 0):
        return 1

    # 왼쪽경로와 위쪽경로를 더한값을 출력
    return search(m - 1, n) + search(m, n - 1)
```

**[실습파일](point1_ex.py)**
