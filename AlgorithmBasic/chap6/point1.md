### 최단경로문제

**실생활 속 최단경로문제**

- 환승안내, 내비게이션과 같은 서비스를 구현하는 경우 여러 경로 중 가장 효율적인 경로를 찾는 알고리즘이 필요하다
- 효율적이란, 시간, 비용, 거리 등 다양한 기준을 고려할 수 있다
- 이를 수치화하여 비용(cost)이라는 값이라고 하며, 비용의 최솟값을 구하는 알고리즘을 구현한다

**최단경로를 구하는 방법**

- 첫번째는 모든 경로를 구하여 최단 경로를 찾는 방법이다, 이 방법은 경로의 수가 증가할 수록 탐색해야하는 데이터 양이 폭발적으로 증가하여 비효율적이다
- 그래프로 표현하기: 방향이 정해진 그래프를 유향 그래프, 방향이 정해지지 않은 그래프를 무향 그래프라고 한다
- 원으로 표현된 곳을 지점, 지나는 곳을 가지라고 한다
- 모든 경로를 지나는 경우 정점이 n개 있으면 복잡도는 `O(n!)`으로 n이 커질수록 급격하게 처리량이 증가한다

**경로의 수 구하기**

- 최단 경로를 구하기 전에 여러 정점이 있는 그래프를 가정하고, 가능한 경로의 수를 구하는 알고리즘을 먼저 살펴본다
- 동적계획법
  - 복잡한 문제의 해결을 위해 작은 문제로 나누고, 해당 값을 저장하여 재활용하는 계산방법
  - 가로, 세로 방향의 지점은 모두 1로 설정(첫행, 첫열)
  - 이후 왼쪽과 아래쪽의 요소를 더한 값을 차례로 대입하여 목적지에 도달하는 경로의 수를 구함
  - 문제의 그림은 5행 6열로 구성된 칸이지만, 코드에서는 왼쪽아래의 출발지점을 배열의[0][0]으로 설정하기 위해 그림을 시계방향으로 돌린 것과 같이 리스트를 구현하였으므로 해석에 유의할 것
  - 즉, 코드에서의 출발지점은 [0][0]이고 도착지점은 [M][N]이 됨

```python
route = [[0 for i in range(N + 1)] for j in range(M + 1)]

# 가로 방향의 첫 1행을 설정
for i in range(M + 1):
    route[i][0] = 1

for i in range(1, N + 1):
    # 세로 방향의 첫 1열을 설정
    route[0][i] = 1
    for j in range(1, M + 1):
        # 왼쪽과 아래쪽의 교차점에 적혀 있는 숫자를 더함
        route[j][i] = route[j - 1][i] + route[j][i - 1]
```

- 메모이제이션
  - 동적계획법의 핵심 아이디어 중 하나, 계산된 값을 저장하여 반복 계산을 피하는 방법이다
  - 재귀함수를 사용할 때 같은 계산을 반복하는 대신 저장한 값을 사용하도록 하여 처리속도를 줄일 수 있다
  - `@functools.lru_cache(maxsize=None)`: 파이썬의 내장 데코레이터인 `@functools.lru_cache`는 함수의 결과를 저장하는 역할을 한다 `maxsize=None`은 저장할 항목의 최대 크기를 제한하지 않겠다는 의미

```python
# 파이썬에서는 아래 1행만 추가하면 재귀처리를 메모이제이션 할 수 있다
@functools.lru_cache(maxsize=None)
def search(m, n):
    # 가로 세로 첫 줄은 모두 1로 설정
    if (m == 0) or (n == 0):
        return 1

    # 왼쪽경로와 위쪽경로를 더한값을 출력
    return search(m - 1, n) + search(m, n - 1)
```

**BFS를 활용한 최단경로문제**

- 문제: N × M 크기의 직사각형 미로가 주어진다. 각각의 칸은 0 또는 1로 표시되어 있고,
  0은 벽, 1은 이동 가능한 칸을 의미한다. 당신은 (1, 1)에서 시작하여 (N, M) 위치로 이동하려고 한다. 이동할 때는 상하좌우로만 이동할 수 있으며, 벽(0)은 통과할 수 없다. 이때, 가장 빠른 경로로 이동할 때 이동하는 칸의 수는 얼마인지 구하시오.
- 시작지점은 (1,1) 도착지점은 (N, M)이며, 1은 길, 0은 벽을 의미한다
- pos를 통해 x,y,depth를 관리한다
- 목표좌표에 도달하면 종료 시작점부터 도착지점까지의 칸 수(이동횟수+1)를 출력하도록한다
- 조건문을 통해 상하좌우를 탐색한다

```python
while len(pos) > 0:
    x, y, depth = pos.pop(0)
    if x == n - 1 and y == m - 1:
        print(depth + 1)
        break
    # 탐색완료 설정
    maze[x][y] = 2
    # 상하좌우(동시)탐색
    if y - 1 >= 0 and maze[x][y - 1] == 1:
        pos.append([x, y - 1, depth + 1])
    if y + 1 < m and maze[x][y + 1] == 1:
        pos.append([x, y + 1, depth + 1])
    if x - 1 >= 0 and maze[x - 1][y] == 1:
        pos.append([x - 1, y, depth + 1])
    if x + 1 < n and maze[x + 1][y] == 1:
        pos.append([x + 1, y, depth + 1])
```

**[실습파일](point1_ex.py)**
