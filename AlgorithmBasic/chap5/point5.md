### 힙 정렬

**리스트 자료구조**

- 이미 저장된 값이 있는 리스트에서 데이터를 추가하거나 삭제할 경우, 공간을 마련하거나 빈 공간을 없애기 위해 여러 데이터를 이동시켜야하는 불편함이 있다
- 리스트의 맨 앞 또는 맨 뒤에서 값을 추가하거나 삭제하는 방식으로 리스트를 효율적으로 사용하는 자료구조가 있다
- 스택stack, 큐queue가 대표적인 자료구조이다
- 해당 챕터에서는 스택과 큐를 소개하고, 힙heap 자료구조에 대한 정렬을 학습한다

**스택Stack**

- 마지막에 저장한 데이터부터 꺼내는 자료구조`LIFO`를 스택이라고 한다
- 데이터 저장은 `push`, 꺼내는 것은 `pop`이라고 한다
- append(): 요소 추가
- pop(): 요소 반환 및 삭제, 인수를 입력하면 해당 인수의 요소를 삭제, 비워두면 가장 최근 입력된 요소를 삭제
- 스택 구현하기

```python
stack = []

stack.append(2)
stack.append(3)
stack.append(5)

temp = stack.pop()
print(temp)  # 마지막 입력 요소인 5 출력
```

**큐Queue**

- 처음에 저장한 데이터부터 꺼내는 자료구조`FIFO`를 큐라고 한다
- 데이터 저장은 `인큐enQueue`, 꺼내는 것은 `디큐deQueue`라고 한다
- 파이썬에서 제공되는 queue 모듈의 Queue클래스를 통해 생성하여, 메서드를 사용할 수 있다
- put(): 요소 추가
- get(): 가장 먼저 입력된 요소를 반환 및 삭제
- 큐 구현하기

```python
import queue

q = queue.Queue()
q.put(2)
q.put(3)
q.put(5)

temp = q.get()
print(temp)  # 첫번째 입력 요소인 2 출력
```

**힙Heap**

- 스택은 맨 뒤의 요소, 큐는 맨 앞의 요소를 꺼낸다면, 힙은 맨 위의 요소(루트)를 꺼낸다
- 트리구조로 자식노드의 값은 항상 부모노드보다 크거나 같다라는 제약이 있다(반대의 제약도 있음)
- 자식노드를 최대 2개 가지는 것을 이진 힙이라고 한다
- 요소 추가: 트리의 마지막에 요소를 추가하고, 추가된 요소와 부모 요소의 크기를 비교하여 제약에 맞게 교환한다
- 요소 꺼내기: 루트 요소를 제거하면 트리 구조가 무너지기 때문에 맨 마지막 요소를 루트에 넣고, 자식 노드와 크기를 비교하여 재구성하는 과정을 거친다
- 요소를 추가 또는 꺼내는 경우 걸리는 시간은 트리의 높이에 따라 달라진다, 이진 힙은 2개의 자식노드만 가지기 때문에 n개의 노드를 가진 트리의 높이는 log2N으로 요소의 추가 및 삭제의 시간복잡도는 `O(logN)`이라고 할 수 있다

**힙 정렬 구현하기**

- 힙을 리스트로 구현할 때 각각의 인덱스n이 n번 노드를 의미하도록 구현한 경우, 인덱스 i에 대하여
  - 부모노드의 인덱스는 i-1 // 2
  - 왼쪽 자식노드는 2i + 1
  - 오른쪽 자식노드는 2i + 2
- data에 대하여 부모노드와 자식노드의 대소비교 `data[(j - 1) // 2] < data[j]`를 통해, 자식이 더 큰 경우 교환한다 => **최대 힙**생성

```python
data = [6, 15, 4, 2, 8, 5, 11, 9, 7, 13]

for i in range(len(data)):
    j = i
    # 부모노드와의 비교가 필요하기 때문에 1번 노드부터 시작
    while (j > 0) and (data[(j - 1) // 2] < data[j]):
        data[(j - 1) // 2], data[j] = data[j], data[(j - 1) // 2]
        # 부모노드의 위치와 바꾸고, 다시 위를 비교하는 과정을 거치는 것임
        j = (j - 1) // 2
```

- 최대 힙으로 정렬된 데이터에 대하여 0번 노드(최댓값)을 i-1번 노드와 변경하는 작업을 반복 => 최솟값부터로 정렬됨
- (나머지 부분)자식노드 2i+1, 2i+2에 대하여 힙 정렬이 무너졌는지 검증, 무너진 경우 값을 교환하여 재정렬하는 과정을 반복

```python
for i in range(len(data), 0, -1):
    # 힙의 맨 앞과 교환
    data[i - 1], data[0] = data[0], data[i - 1]
    j = 0
    while ((2 * j + 1 < i - 1) and (data[j] < data[2 * j + 1])) or (
        (2 * j + 2 < i - 1) and (data[j] < data[2 * j + 2])
    ):
        if (2 * j + 2 == i - 1) or (data[2 * j + 1] > data[2 * j + 2]):
            # 왼쪽 아래와 교환
            data[j], data[2 * j + 1] = data[2 * j + 1], data[j]
            # 왼쪽 아래로 이동
            j = 2 * j + 1
        else:
            # 오른쪽 아래와 교환
            data[j], data[2 * j + 2] = data[2 * j + 2], data[j]
            # 오른쪽 아래로 이동
            j = 2 * j + 2
```

- 힙 정렬의 시간복잡도는 O(logN)으로 삽입, 버블 정렬보다 적지만, 구현이 복잡하다

**힙 정렬 라이브러리**

- heapq 라이브러리를 통해 간단하게 구현할 수 있다
- heapq는 기본적으로 최소 힙을 지원한다
- heapify(): 리스트를 사용하여 최소힙을 구현한다
- heappop(): 루트노드(최솟값)를 꺼내고 나머지 요소들을 알아서 정리한다

```python
def heap_sort(array):
    h = array.copy()
    heapq.heapify(h)  # 힙 생성
    return [heapq.heappop(h) for _ in range(len(array))]
    # 리스트 컴프리헨션 (List Comprehension) 으로 작성, 배열 길이만큼 반복하여, 최솟값부터 꺼내진 값들을 리스트로 리턴함
    # _ 는 실제로 사용하지 않을 쓸모없는 변수명에 대한 관례


data2 = [6, 15, 4, 2, 8, 5, 11, 9, 7, 13]
print(heap_sort(data2))
```

**[실습파일](point5_ex.py)**
