### 버블정렬

**버블정렬이란?**

- 리스트에서 인접한 데이터를 비교해 대소 관계의 순서가 다르면 정렬해나가는 방법
- 데이터의 이동모습이 거품이 수면위로 올라오는 것 같다고 해서 버블정렬이라는 이름이 붙었다
- 리스트의 맨앞부터 두개씩 요소를 비교하여 작은것을 앞(왼쪽) 큰것을 뒤(오른쪽)로 보내는 과정을 반복한다
- 첫번째 교환이 완료되면 가장 큰 값이 맨 오른쪽(n-1번 요소)으로 이동하게 되고, 그 다음 반복부터는 n-2번 요소까지 과정을 반복하게 된다

**버블정렬구현**

- len(data)만큼 실행, 내부 for문을 통해 오른쪽을 줄여나가면서 교환을 실행하게 된다
- 왼쪽값이 클경우 교환

```python
data2 = [6, 15, 4, 2, 8, 5, 11, 9, 7, 13]
for i in range(len(data2)):
    for j in range(0, len(data2) - i - 1):
        if data2[j] > data2[j + 1]:
            data2[j], data2[j + 1] = data2[j + 1], data2[j]

print(data2)
```

- 1회차에 n-1번 비교 및 교환, 2회자에 n-2번 비교 및 교환을 진행하므로 시간복잡도는 정렬여부와 관계없이 `O(n^2)`이다

**버블정렬개선**

- 이미 정렬이 완료된 데이터가 주어진 경우, 변경이 필요없음에도 `O(n^2)`의 시간복잡도를 가지기 때문에 교환 여부에 대한 별도의 변수를 관리하여 복잡도를 줄이도록 개선할 수 있다
- change라는 변수를 통해 교환이 없으면 False, 있으면 True로 값을 설정해두도록하고, 교환이 발생하지 않으면 요소를 교환하는 for문을 실행하지 않고 종료하도록 코드를 작성한다
- 아래의 코드의 경우 정렬이 완료된 데이터가 입력되면 `O(n)`의 시간복잡도로 처리된다, 그러나 최악의 경우에는 여전히 `O(n^2)`의 시간복잡도를 가진다

```python
data3 = [2, 4, 5, 6, 7, 8, 9, 11, 13, 15]
change = True
for i in range(len(data3)):
    # 요소교환이 없는 경우
    if not change:
        break
    change = False  # 요소교환이 발생하지 않은 것으로 설정
    for j in range(0, len(data3) - i - 1):
        if data3[j] > data3[j + 1]:
            data3[j], data3[j + 1] = data3[j + 1], data3[j]
            change = True  # 요소교환이 발생

print(data3)
```
