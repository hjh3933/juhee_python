### 구간 합

**구간 합 이론**

- 합 배열을 이용하여 시간 복잡도를 줄이기 위해 사용하는 특수한 목적의 알고리즘
- 합 배열 정의
  - 기존 리스트를 전처리한 배열
  - 0번 요소부터 i번 요소까지의 전체 합
  - S[i] = A[0]+A[1]+...+A[i]
  - S[i] = S[i-1]+A[i]
  - 기존 리스트의 일정 범위의 합을 구하는 시간 복잡도를 O(N)에서 O(1)로 감소시킬 수 있다
  - i번 요소부터 j번 요소까지의 합
  - S[j]-S[i-1] = 전체합에서 [i-1]번 요소까지의 합을 구한 것과 같기 때문

**문제 003**

- 백준 11659
- 수의 개수, 테스트케이스 개수, 자연수 목록, 케이스별 구간합 인덱스값을 받아 특정 구간합을 출력하는 문제
- 구간마다 합을 매번 계산하면 주어진 제한시간안에 계산을 끝낼 수 없다
- sys.stdin.readline: 입력을 한줄 단위로 빠르게 받음
- 두 번째 for문에서 구간 입력을 받음과 동시에 미리 계산한 합 배열을 통해 구간합을 출력함

```python
for i in numbers:
    temp += i
    prefix_sum.append(temp)

for i in range(0, quizNo):
    s, e = map(int, input().split())
    print(prefix_sum[e] - prefix_sum[s - 1])

```

**문제 004**

- 백준 11660
- 주어진 숫자 N에 대하여 N\*N으로 이루어진 숫자로 가득찬 표가 있다 좌표 x1,y1,x2,y2가 주어졌을 때 해당하는 사각형의 구간합을 구하는 문제
- 2차원배열형식으로 구간합을 저장한다
- 합 배열과 구간 합을 구하는 공식을 세우는 것이 중요한 문제
- N\*N의 배열을 A라고 하고, 합 배열을 D라고 할 때,
- 합 배열[i][j]
  - 1행과 1열의 구간합은 1차원 구간합 배열과 똑같이 구할 수 있음
  - 이후의 구간합은 해당칸 숫자+가로구간합+세로구간합-중복대각선구간합을 통해 계산할 수 있다
  - D[i][j] = D[i-1][j] + D[i][j-1] - D[i-1][j-1] + A[i][j]
- 구간 합 x1,y1 ~ x2,y2
  - x2,y2구간합에서 x1,y1이전의 가로, 세로 구간합을 빼고 중복 구간합을 더한 것과 같다
  - D[x2][y2] - D[x1-1][y2] - D[x2][y1-1] + D[x1-1][y1-1]
- 리스트 선언과 삽입
  - `A = [[0] * (n + 1)]`: n+1개의 [0]요소를 첫번째 행에 추가함
  - `D = [[0] * (n + 1) for _ in range(n + 1)]`: n+1 \* n+1개의 2차원 배열을 생성하고 [0]으로 채움
  - `A_row = [0] + [int(x) for x in input().split()]`: 입력된 행의 숫자들 x를 int형으로 추가하고 맨 앞에 [0] 요소를 추가함
  - 의미: 리스트는 0부터, 좌표는 1부터 시작하기 때문에 인덱스와 좌표값을 동일하게 저장하기위해 행과 열에 각각 0번 줄을 추가해주는 것

```python
for i in range(n):
    A_row = [0] + [int(x) for x in input().split()]
    A.append(A_row)

for i in range(1, n + 1):
    for j in range(1, n + 1):
        D[i][j] = D[i - 1][j] + D[i][j - 1] - D[i - 1][j - 1] + A[i][j]

for _ in range(m):
    x1, y1, x2, y2 = map(int, input().split())
    print(D[x2][y2] - D[x1 - 1][y2] - D[x2][y1 - 1] + D[x1 - 1][y1 - 1])
```

**[실습파일](chap03_2.py)**
