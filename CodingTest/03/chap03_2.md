### 구간 합

**구간 합 이론**

- 합 배열을 이용하여 시간 복잡도를 줄이기 위해 사용하는 특수한 목적의 알고리즘
- 합 배열 정의
  - 기존 리스트를 전처리한 배열
  - 0번 요소부터 i번 요소까지의 전체 합
  - S[i] = A[0]+A[1]+...+A[i]
  - S[i] = S[i-1]+A[i]
  - 기존 리스트의 일정 범위의 합을 구하는 시간 복잡도를 O(N)에서 O(1)로 감소시킬 수 있다
  - i번 요소부터 j번 요소까지의 합
  - S[j]-S[i-1] = 전체합에서 [i-1]번 요소까지의 합을 구한 것과 같기 때문

**문제 003**

- 백준 11659
- 수의 개수, 테스트케이스 개수, 자연수 목록, 케이스별 구간합 인덱스값을 받아 특정 구간합을 출력하는 문제
- 구간마다 합을 매번 계산하면 주어진 제한시간안에 계산을 끝낼 수 없다
- sys.stdin.readline: 입력을 한줄 단위로 빠르게 받음
- 두 번째 for문에서 구간 입력을 받음과 동시에 미리 계산한 합 배열을 통해 구간합을 출력함

```python
for i in numbers:
    temp += i
    prefix_sum.append(temp)

for i in range(0, quizNo):
    s, e = map(int, input().split())
    print(prefix_sum[e] - prefix_sum[s - 1])

```

**문제 004**

- 백준 11660
- 주어진 숫자 N에 대하여 N\*N으로 이루어진 숫자로 가득찬 표가 있다 좌표 x1,y1,x2,y2가 주어졌을 때 해당하는 사각형의 구간합을 구하는 문제
- 2차원배열형식으로 구간합을 저장한다
- 합 배열과 구간 합을 구하는 공식을 세우는 것이 중요한 문제
- N\*N의 배열을 A라고 하고, 합 배열을 D라고 할 때,
- 합 배열[i][j]
  - 1행과 1열의 구간합은 1차원 구간합 배열과 똑같이 구할 수 있음
  - 이후의 구간합은 해당칸 숫자+가로구간합+세로구간합-중복대각선구간합을 통해 계산할 수 있다
  - D[i][j] = D[i-1][j] + D[i][j-1] - D[i-1][j-1] + A[i][j]
- 구간 합 x1,y1 ~ x2,y2
  - x2,y2구간합에서 x1,y1이전의 가로, 세로 구간합을 빼고 중복 구간합을 더한 것과 같다
  - D[x2][y2] - D[x1-1][y2] - D[x2][y1-1] + D[x1-1][y1-1]
- 리스트 선언과 삽입
  - `A = [[0] * (n + 1)]`: n+1개의 [0]요소를 첫번째 행에 추가함
  - `D = [[0] * (n + 1) for _ in range(n + 1)]`: n+1 \* n+1개의 2차원 배열을 생성하고 [0]으로 채움
  - `A_row = [0] + [int(x) for x in input().split()]`: 입력된 행의 숫자들 x를 int형으로 추가하고 맨 앞에 [0] 요소를 추가함
  - 의미: 리스트는 0부터, 좌표는 1부터 시작하기 때문에 인덱스와 좌표값을 동일하게 저장하기위해 행과 열에 각각 0번 줄을 추가해주는 것

```python
for i in range(n):
    A_row = [0] + [int(x) for x in input().split()]
    A.append(A_row)

for i in range(1, n + 1):
    for j in range(1, n + 1):
        D[i][j] = D[i - 1][j] + D[i][j - 1] - D[i - 1][j - 1] + A[i][j]

for _ in range(m):
    x1, y1, x2, y2 = map(int, input().split())
    print(D[x2][y2] - D[x1 - 1][y2] - D[x2][y1 - 1] + D[x1 - 1][y1 - 1])
```

**문제 005**

- 백준 10986
- 숫자의 개수N과 나눌 수 M, N개의 숫자가 순서대로 주어졌을 때 M으로 나누어 떨어지는 구간합의 개수를 구하는 문제
- 나머지 공식
  - `(A+B)%M` = `((A%M)+(B%M))%M`
  - 나머지는 같은데 각자 계산후 합치는 경우엔 나머지의 합 r1+r2가 M 이상의 숫자일 수 있기 때문에(몫이 하나 들어가있는 상태) 다시 한번 M으로 나눠주면 된다. 나머지는 무조건 동일하기 때문에 한번더 M으로 나눠도 같은 값이 나옴
- 구간 합 공식
  - S[j]-S[i] = i+1번부터 j번까지 요소의 합
  - S[j]%M = S[i]%M 이면 (S[j]-S[i])%M이 0이란 의미이므로, 곧 i+1번부터 j까지의 요소의 합이 M으로 나누어 떨어진다는 것을 의미함
- 풀이방법
  - 합배열 S를 구함
  - S의 모든 요소를 M으로 나눠 나머지 값으로 리스트를 갱신
  - 나머지 값이 0이되는경우 0번부터 i번까지 구간의 합이 M으로 나누어 떨어진다는 의미이기 때문에 경우의 수 변수에 해당 개수 추가
  - 나머지 값이 같은 경우를 각각 세고, 그중 2개를 선택하는 nCm 연산으로 개수를 추가(위의 구간합공식의 원리를 참고)
  - `nCk = n! / k!(n-k)!` But, 파이썬에서 `math.comb(n, k)`로 간단히 계산가능
- S[] = 합배열 저장, 크기는 n이므로 [0]\*n선언
- C[] = 나머지당 개수 저장, m으로 나눌때 나머지는 0부터 m-1까지, 즉 m개 이므로 [0]\*m 선언, C[m]은 나머지가 m인 요소의 갯수를 의미함 나중에 nCk 연산에 사용
- math.comb(C[i], 2)로 각 경우의 수 출력해 더함, math.comb()는 import math한 뒤 사용하며, 항상 정수형 값만 리턴함

```python
for i in range(1, n):
    S[i] = S[i - 1] + A[i]

for i in range(len(S)):
    remainder = S[i] % m
    if remainder == 0:
        answer += 1
    C[remainder] += 1

for i in range(m):
    answer += math.comb(C[i], 2)
```

**[실습파일](chap03_2.py)**
